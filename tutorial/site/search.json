{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"OpenCL/OpenGL Interop Particle System","text":"","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#openclopengl-interop-particle-system","level":1,"title":"OpenCL/OpenGL Interop Particle System","text":"<p>This site is a dev-log + tutorial for a GPU particle system where OpenCL does the sim and OpenGL does the drawing, and the two share buffers so nothing has to bounce through the CPU.</p> <p>What “interop” means here</p> <p>OpenGL owns the VBOs (for rendering), OpenCL temporarily acquires those same buffers, writes new particle data, releases them back, then OpenGL draws the updated data.</p> <p>Goal</p> <p>Keep particle positions/colors on the GPU the whole time: simulate in OpenCL, render in OpenGL, repeat.</p>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#getting-started","level":2,"title":"Getting started","text":"","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#what-you-need","level":3,"title":"What you need","text":"","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#build","level":3,"title":"Build","text":"<pre><code>cmake -B build\ncmake --build build\n</code></pre>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#run","level":3,"title":"Run","text":"<pre><code>build\\bin\\Debug\\OpenGLApp.exe\n./build/bin/OpenGLApp\n</code></pre>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#controls","level":3,"title":"Controls","text":"","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#project-layout","level":2,"title":"Project layout","text":"<p>Suggested structure for a Zensical docs site + code repo:</p> <pre><code>├─ src/             # Libraries, Utils, and Shaders\n├─ .clang-format    # Style Guide\n├─ .clangd              \n├─ CMakeLists.txt\n├─ main.cpp         &lt;---- You will edit this file\n└─ particles.cl     &lt;---- You will edit this file   \n</code></pre> <p>How I write pages</p> <p>One page = one idea. Keep the main loop readable and link out to deeper dives (buffers, sync, kernel math).</p>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#the-core-idea","level":2,"title":"The core idea","text":"","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#data-per-particle","level":3,"title":"Data per particle","text":"<p>We’ll keep three arrays on the GPU:</p> <ul> <li>Position: <code>float4 (x, y, z, 1)</code></li> <li>Velocity: <code>float4 (vx, vy, vz, 0)</code></li> <li>Color: <code>float4 (r, g, b, a)</code></li> </ul> <p>Why float4?</p> <p>OpenCL has <code>float4</code> built-in, and the extra component is handy for alignment and convenience.</p>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#simulation-step-high-level","level":3,"title":"Simulation step (high level)","text":"<p>Every frame (or fixed timestep):</p> <ol> <li>Apply gravity</li> <li>Integrate velocity + position</li> <li>Handle collisions (sphere “bumpers” to start)</li> <li>Optionally update color based on “events” (like collisions or speed)</li> </ol>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#openclopengl-buffer-sharing","level":2,"title":"OpenCL/OpenGL buffer sharing","text":"","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#what-gets-shared","level":3,"title":"What gets shared","text":"<p>OpenGL creates VBOs like: - positions VBO (rendered as points / billboards) - colors VBO (optional)</p> <p>OpenCL gets a handle to those buffers so the kernel can write directly into them.</p>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#create-a-shared-vbo-sketch","level":3,"title":"Create a shared VBO (sketch)","text":"<pre><code>// OpenGL: create VBO\nGLuint posVbo = 0;\nglGenBuffers(1, &amp;posVbo);\nglBindBuffer(GL_ARRAY_BUFFER, posVbo);\nglBufferData(GL_ARRAY_BUFFER, numParticles * sizeof(float) * 4, nullptr, GL_DYNAMIC_DRAW);\n\n// OpenCL: wrap GL buffer\ncl_int err = CL_SUCCESS;\ncl_mem clPos = clCreateFromGLBuffer(clContext, CL_MEM_READ_WRITE, posVbo, &amp;err);\n</code></pre> <p>Rule of thumb</p> <p>Let OpenGL “own” the buffer lifetime. OpenCL just borrows it via acquire/release each frame.</p>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#the-per-frame-or-multiple-interop-dance","level":3,"title":"The per-frame or multiple “interop dance”","text":"<pre><code>// Acquire GL buffers for OpenCL\nclEnqueueAcquireGLObjects(queue, 1, &amp;clPos, 0, nullptr, nullptr);\n\n// Run kernel(s) that update positions/colors\n// clSetKernelArg(...)\n// clEnqueueNDRangeKernel(...)\n\n// Release buffers back to OpenGL\nclEnqueueReleaseGLObjects(queue, 1, &amp;clPos, 0, nullptr, nullptr);\n\n// Make sure CL is done before GL draws from the buffer\nclFinish(queue);\n</code></pre> <p>Sync matters</p> <p>If you see flicker, one-frame lag, or random garbage: it’s usually missing/incorrect sync around acquire/release (or you’re writing out of bounds).</p>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#the-kernel-simple-version","level":2,"title":"The kernel (simple version)","text":"","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#inputsoutputs","level":3,"title":"Inputs/outputs","text":"<ul> <li><code>dPos</code> (shared buffer): read+write</li> <li><code>dVel</code> (OpenCL-only buffer): read+write</li> <li><code>dCol</code> (shared buffer): optional write</li> </ul>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#pseudocode","level":3,"title":"Pseudocode","text":"<pre><code>kernel void StepParticles(\n    global float4* dPos,\n    global float4* dVel,\n    global float4* dCol,\n    float dt,\n    float4 gravity,\n    float4 sphere0,   // (cx, cy, cz, r)\n    float4 sphere1\n) {\n    int id = get_global_id(0);\n\n    float4 p = dPos[id];\n    float4 v = dVel[id];\n\n    // Integrate\n    v += gravity * dt;\n    p += v * dt;\n    p.w = 1.0f;\n    v.w = 0.0f;\n\n    // Collide with spheres (outline)\n    // if (insideSphere(p, sphere0)) v = bounce(...);\n    // if (insideSphere(p, sphere1)) v = bounce(...);\n\n    // Optional: color update\n    // dCol[id] = ...\n\n    dPos[id] = p;\n    dVel[id] = v;\n}\n</code></pre> <p>Start with something boring</p> <p>First make particles fall correctly. Then add one sphere collision. Then add the second sphere. Then add colors.</p>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]}]}