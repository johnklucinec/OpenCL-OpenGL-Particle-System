{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"OpenCL/OpenGL Interop Particle System","text":"","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#introduction","level":2,"title":"Introduction","text":"<p>Particle systems are used in games, films, and visual effects to simulate natural phenomena such as clouds, dust, fireworks, fire, explosions, water flow, sand, swarms of insects, and even herds of animals. Once you understand how they work, you'll notice them everywhere.</p> <p>A particle system operates by controlling an extensive collection of individual 3D particles to exhibit some behavior. For a deeper technical overview, see Mike Bailey's slide.</p> <p>Fun Fact</p> <p>Particle systems were first seen in Star Trek II: The Wrath of Khan Genesis Demo, animated over 40 years ago. While the technology has evolved significantly since then, this groundbreaking sequence introduced the concept to computer graphics.</p>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#goal","level":2,"title":"Goal","text":"<p>In this project, you will combine OpenCL and OpenGL to create your own particle system.  The project template includes a complete solution for one million (1024 x 1024) particles, one sphere bumper, and no color changes. The files you need to change are <code>sample.cpp</code> and <code>particles.cl</code>. The degree of \"cool-ness\" is up to you, but here is a minimum checklist you must complete to get full credit. For more in-depth instructions, see the Requirements section.</p> <ul> <li> Choose an appropriate <code>LOCAL_SIZE</code> value</li> <li> Select an optimal <code>STEPS_PER_FRAME</code> value  </li> <li> Add at least one additional bumper object (sphere)</li> <li> Implement dynamic particle color changes</li> <li> Test performance with varying particle counts</li> <li> Create a graph to visualize your results</li> <li> Demonstrate your program in action</li> </ul> <p>What interoperability or \"interop\" means here</p> <p>OpenGL owns the VBOs (for rendering), OpenCL temporarily acquires those same buffers, writes new particle data, releases them back, and then OpenGL draws the updated data.</p>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#getting-started","level":2,"title":"Getting Started","text":"<p>This project uses CMake as the build system to ensure it runs on Windows, macOS, and Linux. It's written in C++ 17 and uses OpenGL 4.1 and OpenCL 1.2, as these are the latest versions supported on macOS. OpenMP is used for kernel benchmarking. If you need to install any of these, detailed instructions for each operating system are provided below.</p>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#project-layout","level":4,"title":"Project Layout","text":"<pre><code>├─ src/                 # Libraries, utils, and shaders\n├─ .clang-format        # Style Guide\n├─ .clangd              \n├─ CMakeLists.txt\n├─ main.cpp             # You will edit this file\n└─ particles.cl         # You will edit this file   \n</code></pre> <p>To build the project, run these commands from your terminal:</p> <pre><code>cmake -B build\ncmake --build build\n</code></pre> Windows <p>TODO</p> MacOS <p>TODO</p> Linux <p>TODO</p>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#requirements","level":2,"title":"Requirements","text":"","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#1-set-local-work-group-size","level":4,"title":"1. Set Local Work-Group Size","text":"<p>Set the local work-group size (<code>LOCAL_SIZE</code>) to some fixed value. You can determine an appropriate value by setting <code>PRINTINFO</code> to true, which shows the maximum work-group size your GPU supports. Since this particle system uses simple calculations, pick a reasonable power of 2 (like 128 or 256) within that maximum, set it once, and leave it.</p>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#2-set-optimal-steps-per-frame","level":4,"title":"2. Set Optimal Steps Per Frame","text":"<p>First, it's important to understand how the default program flow works</p> Program Execution Flow <p> <p> Source <p>Looking at the graph, once we set up the data on the OpenGL side, OpenCL acquires it. As explained in the OpenCL/GL Interoperability notes, synchronization is required because only one can hold the buffer at a time. OpenCL runs a kernel that reads an x, y, and z value, updates it according to projectile motion laws, writes it back to the buffer, and releases it. OpenGL then draws the buffer, and the cycle repeats.</p> <p>While this system works, it means only one physics update happens per visual frame. If you're locked to your monitor's refresh rate (let's assume 60Hz), you'll draw 60 frames per second, which is your framerate.</p> <p>But here's the catch: Just because you can only draw 60 frames per second doesn't mean you can only compute 60 times per second.</p> <p><code>STEPS_PER_FRAME)</code> determines how many compute kernels are launched before drawing a frame. We want to know \"How fast can my GPU update particles?\" not \"How many frames can I draw?\" When <code>STEPS_PER_FRAME</code> is set higher than 1, you're running multiple physics updates per visual frame.</p> <p>Think of your GPU like a delivery truck. Every frame is a \"trip\", and every kernel compute is a \"package\".</p> <ul> <li>Make 1 delivery per trip (<code>STEPS_PER_FRAME</code> = 1): You drive to one house, drop off a package, drive all the way back, then wait for the next scheduled trip. Inefficient!</li> <li>Make 10 deliveries per trip (<code>STEPS_PER_FRAME</code> = 10): You drive out once, hit 10 houses, then come back. You're doing 10 times more work in the same wall-clock time.</li> </ul> <p>Your GPU has limits, so setting the value too high will hurt your framerate. Your goal is to find the value that stresses your GPU the most while maintaining fluid motion. An easy way is to increase the value until your FPS drops to around your monitor's refresh rate.</p> <p>Test with your maximum particle count when finding this value.</p>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#3-add-additional-bumper-object","level":4,"title":"3. Add Additional Bumper Object","text":"<p>Your simulation must have at least two \"bumpers\" in it for the particles to bounce off of. Each bumper needs to be geometrically designed such that, given particles XYX, you can quickly tell if that particle is inside or outside the bumper. To get the bounce right, each bumper must know its outward-facing surface normal everywhere.</p> <p>What's the easiest shape for a bumper? A sphere! In computer graphics, we love spheres as they are computationally \"nice\". It's fast and straightforward to tell if something is inside or outside of a sphere. It's just as straightforward to determine a normal vector for a point on the surface of a sphere, too.</p> <p>It is OK to assume that the two bumpers are separate from each other; that is, a particle cannot collide with both at the same time.</p> <p>Your OpenCL <code>.cl</code> program must also handle bounces from your (&gt;=2) bumpers. Be sure to draw these bumpers in your <code>.cpp</code> program in <code>InitLists()</code> so that you can see where they are.</p> <p>Warning</p> <p>Don't forget to update the <code>.cl</code> kernel code with the same values you set in your <code>.cpp</code> code.</p>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#4-implement-dynamic-color-changes","level":4,"title":"4. Implement Dynamic Color Changes","text":"<p>The sample OpenCL code does not retrieve the colors, modify them, or restore them. However, your <code>.cl</code> kernel needs to change the particles' colors dynamically. You could base this on position, velocity, time, bounce knowledge, etc. The way they change is up to you, but the color of each particle needs to change in some predictable way during the simulation.</p> <p>OpenGL defines the red, green, and blue components of a color each as a floating-point value between <code>0.0</code> and <code>1.0</code></p>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#5-test-performance","level":4,"title":"5. Test Performance","text":"<p>Vary the total number of particles from something small-ish (~1024) to something big-ish (~1024*1024) in some increments that will look good on the graph.</p> <p>If you check the \"show performance\" box, you will see current, peak, and average measurements. Let the simulation run for a few seconds, and then write down your Average GigaParticles/Sec.</p>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#6-show-results","level":4,"title":"6. Show Results","text":"<p>Make a table and a graph of Performance versus Total Number of Particles.</p> That this will just be one graph with one curve. <p>TODO: Add graph example + python code to make one?</p> <p>Bonus</p> <p>If you have some free time, run all the tests again with different work group sizes and compare the results.</p>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#7-demonstrate-your-program-in-action","level":4,"title":"7. Demonstrate your program in action","text":"<p>Make a video of your program in action and be sure it's Unlisted. You can use any video-capture tool you want. If you have never done this before, I recommend Kaltura, for which OSU has a site license for you to use. You can access the Kaltura noteset here. If you use Kaltura, be sure your video is set to Unlisted. If it isn't, then we won't be able to see it, and we can't grade your project.</p> <p>Sites like YouTube also work. Just make sure your video is either public or unlisted, not private.</p> <p>Tip</p> <p>Copy and paste your video link into an incognito tab and see if it plays. If it does, you should be good to go.</p>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#8-commentary-in-the-pdf-file","level":4,"title":"8. Commentary in the PDF file","text":"<p>Your commentary PDF should include:</p> <ol> <li>A web link to the video showing your program in action -- be sure your video is Unlisted.</li> <li>What machine did you run this on?</li> <li>What predictable dynamic thing did you do with the particle colors (random changes are not good enough)?</li> <li>Include at least one screenshot of your project in action</li> <li>Show the table and graph.</li> <li>What patterns are you seeing in the performance curve?</li> <li>Why do you think the patterns look this way?</li> <li>What does that mean for the proper use of GPU parallel computing?</li> </ol>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#tips","level":2,"title":"Tips","text":"Explaining the Sample Code – TODO <p>TODO: Add explaination</p> Explaining the Kernel – Advancing a Particle by DT TODO: UPDATE CODE <p>In the sample code, Joe Parallel wanted to clean up the code by treating x, y, z positions and velocities as single variables instead of handling each component separately. To do this, he created custom types called <code>point</code>, <code>vector</code>, and <code>color</code> using typedef, all backed by OpenCL's <code>float4</code> type. (OpenCL doesn't have a <code>float3</code>, so <code>float4</code> is the next best option, the fourth component goes unused.) He also stored sphere definitions as a <code>float4</code>, packing the center coordinates and radius as x, y, z, r.</p> <pre><code>typedef float4 point;   // x, y, z, 1.\ntypedef float4 vector;  // vx, vy, vz, 0.\ntypedef float4 color;   // r, g, b, a\ntypedef float4 sphere;  // x, y, z, r\n\nconstant sphere Sphere1 = (sphere)( -100., -800., 0., 600. );\n</code></pre> <p>Joe Parallel also stored the (x,y,z) acceleration of gravity in a <code>float4</code>:</p> <pre><code>constant float4 G = (float4) (0.0, -9.8, 0.0, 0.0);\n</code></pre> <p>Now, given a particle's position <code>point p</code> and a particle's velocity <code>vector v</code>, here is how you advance it one time step:</p> <pre><code>kernel\nvoid\nParticle( global point *dPobj, global vector *dVel, global color *dCobj )\n{\n    int gid = get_global_id( 0 ); // particle number\n\n    point p = dPobj[gid];\n    vector v = dVel[gid];\n    color c = dCobj[gid];\n\n    point pp = p + v*DT + G*(point)( .5*DT*DT ); // p'\n    vector vp = v + G*DT; // v'\n\n    pp.w = 1.0;\n    vp.w = 0.0;\n</code></pre> <p>Bouncing is handled by changing the velocity vector according to the outward-facing surface normal of the bumper at the point right before an impact:</p> <pre><code>    if( IsInsideSphere( pp, Sphere1 ) )\n    {\n        vp = BounceSphere( p, v, Sphere1 );\n        pp = p + vp*DT + G*(point)( .5*DT*DT );\n    }\n</code></pre> <p>And then do this again for the second bumper object. Assigning the new positions and velocities back into the global buffers happens like this:</p> <pre><code>    dPobj[gid] = pp;\n    dVel[gid] = vp;\n    dCobj[gid] = ????; // some change in color based on something \n                    // happening in the simulation\n}\n</code></pre> <p>Some utility functions you might find helpful:</p> <pre><code>bool\nIsInsideSphere( point p, sphere s )\n{\n    float r = fast_length( p.xyz - s.xyz );\n    return ( r &lt; s.w );\n}\n</code></pre> <pre><code>vector\nBounce( vector in, vector n )\n{\n    n.w = 0.;\n    n = fast_normalize( n );\n    vector out = in - n*(vector)( 2.*dot(in.xyz, n.xyz) ); // angle of reflection equals\n                                                            // angle of incidence\n    out.w = 0.;\n    return out;\n}\n</code></pre> <pre><code>vector\nBounceSphere( point p, vector in, sphere s )\n{\n    vector n;\n    n.xyz = fast_normalize( p.xyz - s.xyz );\n    n.w = 0.;\n    return Bounce( in, n );\n}\n</code></pre> Getting an Error Message that says something about \"UTF-8\"? <p>TODO: Find the actual source for this: This is the problem where Windows text editors put 2 marks at the end of a text line instead of the expected one mark. Refer to Slide #43 of the Project Notes noteset. </p> Determining Platform and Device Information <p>TODO: Add stuff about VSYNC</p> <p>The sample code includes code from the printinfo program. This will show what OpenCL capabilities are on your system. The code will also attempt to pick the best OpenCL environment. Feel free to change this if you think it has picked the wrong one. </p>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]},{"location":"#grading","level":2,"title":"Grading","text":"Requirement Points Convincing particle motion 20 Bouncing from at least two bumpers 20 Predictable dynamic color changes (random changes are not good enough) 30 Performance table and graph 20 Commentary in the PDF file 30 Potential Total 120 <p>Success</p> <p>The motion, bouncing, and colors of the particles need to be demonstrated via a video link. If it is a Kaltura video, be sure it has been set to Unlisted.</p>","path":["OpenCL/OpenGL Interop Particle System"],"tags":[]}]}